#ifndef MAC_H
#define MAC_H

#include "constants.hpp"
#include "mesh/vtk_structured.hpp"
#include "geometry/assembly.hpp"
#include "util/point.hpp"
#include "util/box.hpp"
#include "geometry/voxel_particle_geometry.hpp"

#include "Eigen/Core"

#include <string>
#include <sstream>
#include <fstream>
#include <functional> //for passing method functions to solvers

#include <omp.h>

//Convenient typedefs
using StructuredPoints = GeoVox::mesh::StructuredPoints;
using Assembly = GeoVox::geometry::Assembly;
using VectorXd = Eigen::VectorXd;


namespace GeoVox::mac{
	class MacMesh{
	public:
		MacMesh(const Box& box, const long unsigned int _N[3], const Assembly* const assembly) : mu(1.0), tol(MAC_DEFAULT_TOL), N(_N), assembly(assembly), box(box) {
			//get spacing between DOFs
			H = box.sidelength().array()/Point3(N[0], N[1], N[2]).array();

			//create masks
			Point3 offset_low = 0.5*H;
			Point3 offset_high = 0.5*H;
			Box subbox = Box(box.low()+offset_low, box.high()-offset_high);
			p_mask = assembly->make_structured_mesh(subbox, _N);

			offset_low = Point3(0, 0.5*H[1], 0.5*H[2]);
			offset_high = Point3(H[0], 0.5*H[1], 0.5*H[2]);
			subbox = Box(box.low()+offset_low, box.high()-offset_high);
			u_mask = assembly->make_structured_mesh(subbox, _N);

			offset_low = Point3(0.5*H[0], 0, 0.5*H[2]);
			offset_high = Point3(0.5*H[0], H[1], 0.5*H[2]);
			subbox = Box(box.low()+offset_low, box.high()-offset_high);
			v_mask = assembly->make_structured_mesh(subbox, _N);

			offset_low = Point3(0.5*H[0], 0.5*H[1], 0);
			offset_high = Point3(0.5*H[0], 0.5*H[1], H[2]);
			subbox = Box(box.low()+offset_low, box.high()-offset_high);
			w_mask = assembly->make_structured_mesh(subbox, _N);

			//initialize unkowns to 0
			p = VectorXd::Zero(N.prod());
			u = VectorXd::Zero(N.prod());
			v = VectorXd::Zero(N.prod());
			w = VectorXd::Zero(N.prod());

			//initialize forcing terms to 0
			f1 = VectorXd::Zero(N.prod());
			f2 = VectorXd::Zero(N.prod());
			f3 = VectorXd::Zero(N.prod());
			g  = VectorXd::Zero(N.prod());
		}

		
		//Viscosity
		double mu;

		//Solver parameters
		int max_outer_iterations; //Maximum number of outer Distributive Gauss-Seidel (DGS) iterations
		double tol; //Outer iteration residual tolerance for each equation (u,v,w) momentum equations (p) mass conservation equation
		// double SCALE; //Scaling factor to multiply both sides. Should be O(h^2).

		//DOF masks (periodic BC, so the number of DOFs are the same)
		Eigen::Matrix<long unsigned int, 3, 1> N;
		Point3 H;
		inline long unsigned int index(long unsigned int i, long unsigned int j, long unsigned k) const {return (i%N[0]) + N[0]*( (j%N[1]) + N[1]*(k%N[2]) );}
		inline long unsigned int fine_index(long unsigned int i, long unsigned int j, long unsigned k) const {long unsigned int M[3] {2*N[0], 2*N[1], 2*N[2]}; return (i%M[0]) + M[0]*( (j%M[1]) + M[1]*(k%M[2]));}
		inline long unsigned int coarse_index(long unsigned int i, long unsigned int j, long unsigned k) const {long unsigned int M[3] {N[0]/2, N[1]/2, N[2]/2}; return (i%M[0]) + M[0]*( (j%M[1]) + M[1]*(k%M[2]));}

		StructuredPoints p_mask; //pressure mask (global indexing): Nx by Ny by Nz
		StructuredPoints u_mask; //x-velocity mask (global indexing): Nx by Ny by Nz
		StructuredPoints v_mask; //y-velocity mask (global indexing): Nx by Ny by Nz
		StructuredPoints w_mask; //z-velocity mask (global indexing): Nx by Ny by Nz

		//DOF values
		VectorXd p; //pressure values (reduced indexing): number of nonzeros in p_mask
		VectorXd u; //x-velocity values (reduced indexing): number of nonzeros in
		VectorXd v; //y-velocity values (reduced indexing)
		VectorXd w; //z-velocity values (reduced indexing)

		//RHS values
		VectorXd f1; //forcing term in x-direction at x-DOFs
		VectorXd f2; //forcing term in y-direction at y-DOFs
		VectorXd f3; //forcing term in z-direction at z-DOFsS
		VectorXd g;  //forcing term for p at p-DOFs
		
		//Geometry
		const Assembly* const assembly;
		const Box box;

		//FIRST DERIVATIVES
		VectorXd dPdX(const VectorXd& variable) const;
		VectorXd dPdY(const VectorXd& variable) const;
		VectorXd dPdZ(const VectorXd& variable) const;

		VectorXd dUdX(const VectorXd& variable) const;
		VectorXd dVdY(const VectorXd& variable) const;
		VectorXd dWdZ(const VectorXd& variable) const;


		//SECOND DERIVATIVES
		VectorXd A(const VectorXd& variable) const; //same template for u,v,w
		VectorXd Ap(const VectorXd& variable) const;

		//SOLUTION
		void GS_relax_velocity();
		void GS_relax_velocity_reverse();
		VectorXd GS_relax_p() const; //Return ep = Ap_inv(g-Bx(u)-By(v)-Bz(w))
		VectorXd GS_relax_p_reverse() const;
		void setRockVelocity();

		void DGS();
		void DGS_reverse(); //for symmetric Gauss-Seidel iterations
		void solve(const int max_iter=MAC_DEFAULT_MAX_OUTER_ITERATIONS);
		void solve_reverse(const int max_iter=MAC_DEFAULT_MAX_OUTER_ITERATIONS);
		
		void solve_multigrid(int m);
		void coarsen(VectorXd& U, VectorXd& V, VectorXd& W, VectorXd& P);
		void refine(VectorXd& U, VectorXd& V, VectorXd& W, VectorXd& P);

		//save solution interpolated to pressure DOFs
		void saveas(const std::string filename) const;
	};
}


#endif