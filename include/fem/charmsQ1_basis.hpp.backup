//These classes are helper classes to implement the CHARMS
//(Conforming, Hierarchical, Adaptive Refinement Methods)
//method for finite elements.
//Paper: "CHARMS: A Simple Framework for Adaptive Simulation" (2002)
//Authors: Eitan Grinspun, Petr Krysl, Peter Schroder



#pragma once

#include "util/point.hpp"
#include "util/box.hpp"
#include "util/octree.hpp"
#include "util/point_octree.hpp"

#include <vector>
#include <set>
#include <algorithm>
#include <cassert>

#include <sstream>
#include <iostream>
#include <fstream>

namespace gv::fem
{
	class BasisFunctionQ1
	{
	public:
		//common typedefs
		using VertexList_t = gv::util::PointOctree<3>;
		using Point_t      = gv::util::Point<3,double>;

		//default constructor for creating arrays (TODO: how do I avoid this excess initialization?)
		BasisFunctionQ1() : vertices(nullptr), node_idx((size_t) -1), depth(0) {}

		//construct basis function by reference to the vertex index. support managemement must be done outside of this class.
		BasisFunctionQ1(VertexList_t* vertices, const size_t node_idx, const int depth) :
			vertices(vertices), node_idx(node_idx), depth(depth) {assert(node_idx<(*vertices).size());}

		VertexList_t* vertices; //pointer to list of vertices

		size_t node_idx; //this basis function "lives" at this vertex
		int depth; //number of divisions of the root element required to reach this basis function. must be equall to the depth of all elements in its support.
		std::set<size_t> support; //natural support of this basis function, the elements must be active and on the same depth as this basis function
		bool is_active = false; //rather than deleting basis functions on un-refinement, set is_active to false
		bool is_refined = false; //track if this basis function has been refined
		bool is_odd = false; //track if this basis function is even or odd. set manually and never change.
		Point_t coord() const {return (*vertices)[node_idx];} //get coordinate where this basis function "lives". used for octree storage
		bool operator==(const BasisFunctionQ1& other) const //determine if two basis functions are the same. used in constructing octrees
		{
			if (vertices!=other.vertices) {return false;} //ensure both basis functions refer to the same list of vertices
			if (depth!=other.depth) {return false;}
			if (node_idx!=other.node_idx) {return false;}
			return true; //same vertex location and depth
		}

		//move assignment
		BasisFunctionQ1& operator=(BasisFunctionQ1&& other) noexcept
		{
			if (this!=&other)
			{
				vertices   = other.vertices;
				node_idx   = other.node_idx;
				depth      = other.depth;
				is_active  = other.is_active;
				is_refined = other.is_refined;
				support    = std::move(other.support);
				is_odd     = other.is_odd;
			}
			return *this;
		}

		//copy assignment
		BasisFunctionQ1& operator=(const BasisFunctionQ1& other)
		{
			vertices   = other.vertices;
			node_idx   = other.node_idx;
			depth      = other.depth;
			is_active  = other.is_active;
			is_refined = other.is_refined;
			support    = other.support;
			is_odd     = other.is_odd;
			return *this;
		}
	};

	//OCTREE BASED STORAGE CONTAINER FOR A LIST OF BASIS FUNCTIONS
	class BasisFunctionQ1Octree : public gv::util::BasicOctree<BasisFunctionQ1,3,32>
	{
	public:
		BasisFunctionQ1Octree(const gv::util::Box<3> &domain) : gv::util::BasicOctree<BasisFunctionQ1,3,32>(domain, 64) {}
		std::vector<size_t> get_basis_functions_with_coordinate(const gv::util::Point<3,double> &coord) const
		{
			const Node_t* octree_node = _get_node(coord); //get the first leaf node that contains the coordinate

			//check each of the data points
			std::vector<size_t> result;
			for (int idx=0; idx<octree_node->data_cursor; idx++)
			{
				size_t d_idx = octree_node->data_idx[idx];
				if ((*this)[d_idx].coord()==coord) {result.push_back(d_idx);}
			}

			return result;
		}
	private:
		bool is_data_valid(const gv::util::Box<3> &box, const BasisFunctionQ1 &data) const override {return box.contains(data.coord());}
	};
}