//These classes are helper classes to implement the CHARMS
//(Conforming, Hierarchical, Adaptive Refinement Methods)
//method for finite elements.
//Paper: "CHARMS: A Simple Framework for Adaptive Simulation" (2002)
//Authors: Eitan Grinspun, Petr Krysl, Peter Schroder



#pragma once

#include "util/point.hpp"
#include "util/box.hpp"
#include "util/octree.hpp"
#include "util/point_octree.hpp"

#include <vector>
#include <set>
#include <algorithm>
#include <cassert>

#include <sstream>
#include <iostream>
#include <fstream>

namespace gv::fem
{
	// //classes defined in this file
	// class ElementQ1; //logic for tracking voxel elements
	// class ElementQ1Octree; //container for voxel elements (built from gv::util::BasicOctree)
	// class BasisFunctionQ1; //logic for tracking basis functions
	// class BasisFunctionQ1Octree; //container for basis functions (build from gv::util::BasicOctree)
	// class CharmsQ1Mesh; //main class used for interacting with the CHARMS mesh (Q1 voxel elements in 3D)


	//////////////// ELEMENT IMPLEMENTATION ////////////////
	class ElementQ1
	{
	public:
		//common typedefs
		using VertexList_t = gv::util::PointOctree<3>;
		using Index_t      = gv::util::Point<3,size_t>;
		using Point_t      = gv::util::Point<3,double>;
		using Box_t        = gv::util::Box<3>;

		//default constructor for creating arrays (TODO: how do I avoid this excess initialization?)
		ElementQ1() : depth(0), vertices(nullptr), nodes(nullptr), parent(nullptr), children(nullptr), sibling_number(-1) {}

		//constructor for coarsest mesh
		ElementQ1(const Box_t& bbox, VertexList_t* vertices, bool add_vertices=true) :
			depth(0),
			vertices(vertices),
			nodes(new size_t[8]),
			parent(nullptr),
			children(new ElementQ1*[8]),
			sibling_number(-1)
		{
			//add vertices if necessary and find their indices. add these indices nodes[]
			for (int k=0; k<8; k++)
			{
				Point_t vertex = bbox.voxelvertex(k);
				size_t idx;
				if (add_vertices) //allow this construction to add vertices if needed
				{
					int flag = vertices->push_back(vertex, idx);
					assert(flag!=-1); //ensure node was added succesfully
				}
				else //use add_vertices=false if the element should have already been constructed
				{
					idx = vertices->find(vertex);
					assert(idx!=(size_t) -1); //ensure vertex was found
				}
				nodes[k] = idx;
				children[k] = nullptr;
			}
		}

		//constructor for refinements, refering only to the coarsest mesh
		ElementQ1(ElementQ1* parent, int sibling_number, bool add_vertices=true) : 
			depth(parent->depth+1),
			vertices(parent->vertices),
			nodes(new size_t[8]),
			parent(parent),
			children(new ElementQ1*[8]),
			sibling_number(sibling_number)
		{
			std::cout << "parent->children[" << sibling_number << "]= " << parent->children[sibling_number] << std::endl;
			//pass information back to the parent
			parent->children[sibling_number] = this;
			parent->is_refined = true;

			//get bounding box for this element
			Box_t bbox(parent->center(), (*vertices)[parent->nodes[sibling_number]]);
			
			//convert index triplet to vertices and find their indices. add to vertices if necessary.
			for (int k=0; k<8; k++)
			{
				Point_t vertex = bbox.voxelvertex(k);
				size_t idx;
				if (add_vertices) //allow this construction to add vertices if needed
				{
					int flag = vertices->push_back(vertex, idx);
					assert(flag!=-1); //ensure node was added succesfully
				}
				else //use add_vertices=false if the element should have already been constructed
				{
					idx = vertices->find(vertex);
					assert(idx!=(size_t) -1); //ensure vertex was found
				}

				assert(idx<vertices->size());
				nodes[k] = idx;
			}
		}

		//destructor
		~ElementQ1()
		{
			if (nodes!=nullptr) {delete[] nodes; nodes=nullptr;}
			if (children!=nullptr) {delete[] children; children=nullptr;}
		}

		int depth; //number of divisions of the root element required to reach this element
		VertexList_t* vertices; //pointer to list of vertices

		size_t* nodes; //mesh information. indices of nodes that make this element (vtk voxel ordering)
		static const int vtk_id = 11; //all elements are vtk voxels
		bool is_active = false; //rather than deleting elements for un-refinement, set is_active to false
		bool is_refined = false; //set to true when this element has been subdivided
		std::set<size_t> basis_a; //indices of active ancestor basis functions whose support overlaps with this element. TODO: change to set?
		std::set<size_t> basis_s; //indices of active same-level basis functions whose support overlaps with this element. TODO: change to set?
		
		//track tree structure here. TODO: is it best to just re-implement the octree for these elements?
		ElementQ1* parent;
		ElementQ1** children;
		int sibling_number;

		bool contains(const Point_t& coord) const {return (*vertices)[nodes[0]]<=coord and coord<=(*vertices)[nodes[7]];} //check if the element contains the specified coordinate
		Point_t H() const {return (*vertices)[nodes[7]]-(*vertices)[nodes[0]];}
		Point_t center() const {return 0.5*( (*vertices)[nodes[0]] + (*vertices)[nodes[7]]);} //return center of this element
		Box_t bbox() const {return Box_t{(*vertices)[nodes[0]], (*vertices)[nodes[7]]};} //return the bounding box, used for octree storage
		bool operator==(const ElementQ1 &other) const //compare two elements by their nodes. used for octree storage
		{
			if (vertices!=other.vertices) {return false;} //elements must use the same vertex list
			for (int k=0; k<8; k++) {if (nodes[k]!=other.nodes[k]) {return false;} } //elements must have the same node indices
			return true;
		}

		//move assignment
		ElementQ1& operator=(ElementQ1&& other) noexcept
		{
			std::cout << "element move operator" << std::endl;
			if (this!=&other)
			{
				depth       = other.depth;
				vertices    = other.vertices;
				is_active   = other.is_active;
				is_refined  = other.is_refined;

				nodes       = other.nodes; other.nodes = nullptr;
				parent      = other.parent; other.parent = nullptr;
				children    = other.children; other.children = nullptr;

				// for (int i=0; i<8; i++)
				// {
				// 	children[i] = other.children[i];
				// 	other.children[i] = nullptr;
				// }

				sibling_number = other.sibling_number;

				basis_a     = std::move(other.basis_a);
				basis_s     = std::move(other.basis_s);
			}
			return *this;
		}

		//copy assignment
		ElementQ1& operator=(const ElementQ1& other)
		{
			std::cout << "element copy assignment" << std::endl;

			depth       = other.depth;
			vertices    = other.vertices;
			is_active   = other.is_active;
			is_refined  = other.is_refined;
			
			if (nodes==nullptr) {nodes=new size_t[8];}
			for (int i=0; i<8; i++) {nodes[i]=other.nodes[i];}

			parent      = other.parent;

			if (children==nullptr) {children = new ElementQ1*[8];}
			for (int i=0; i<8; i++) {children[i]=other.children[i];}

			sibling_number = other.sibling_number;

			basis_a     = other.basis_a;
			basis_s     = other.basis_s;

			return *this;
		}
	};

	//OCTREE BASED STORAGE CONTAINER FOR A LIST OF ELEMENTS
	class ElementQ1Octree : public gv::util::BasicOctree<ElementQ1,3,16>
	{
	public:
		ElementQ1Octree(const gv::util::Box<3> &domain) : gv::util::BasicOctree<ElementQ1,3,16>(domain,64) {}
		std::set<size_t> get_elements_containing_coordinate(const Point_t &coord) const
		{
			std::vector<size_t> indices = get_data_indices(coord);
			std::set<size_t> result;
			for (size_t idx=0; idx<indices.size(); idx++)
			{
				size_t e_idx = indices[idx];
				const ElementQ1& ELEM = (*this)[e_idx];
				if (ELEM.contains(coord)) {result.insert(e_idx);}
			}
			assert(result.size()>0);
			return result;
		}

		std::set<size_t> get_elements_containing_coordinate(const Point_t &coord, const int depth) const
		{
			std::vector<size_t> indices = get_data_indices(coord);
			std::set<size_t> result;
			for (size_t idx=0; idx<indices.size(); idx++)
			{
				size_t e_idx = indices[idx];
				const ElementQ1& ELEM = (*this)[e_idx];
				if (ELEM.contains(coord) and ELEM.depth==depth) {result.insert(e_idx);}
			}
			assert(result.size()>0);
			return result;
		}
	private:
		bool is_data_valid(const gv::util::Box<3> &box, const ElementQ1 &data) const override {return box.intersects(data.bbox());}
	};
}